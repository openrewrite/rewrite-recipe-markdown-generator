@file:Suppress("SENSELESS_COMPARISON")

package org.openrewrite

import org.openrewrite.RecipeMarkdownGenerator.Companion.useAndApply
import org.openrewrite.RecipeMarkdownGenerator.Companion.writeln
import org.openrewrite.config.RecipeDescriptor
import java.net.URI
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.*

class ListsOfRecipesWriter(
    val allRecipeDescriptors: List<RecipeDescriptor>,
    val outputPath: Path,
    val recipeLinkBasePath: String = "/recipes"
) {
    fun createModerneRecipes(moderneProprietaryRecipesMap: TreeMap<String, MutableList<RecipeDescriptor>>) {
        val moderneRecipesPath = outputPath.resolve("moderne-recipes.md")

        Files.newBufferedWriter(moderneRecipesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
        ---
        description: An autogenerated list of recipes that are exclusive to Moderne.
        ---
        """.trimIndent()
            )
            writeln("\n# Moderne Recipes\n")

            writeln(
                "This doc includes every recipe that is exclusive to users of Moderne. " +
                        "For a full list of all recipes, check out our [recipe catalog](https://docs.moderne.io/user-documentation/recipes/recipe-catalog). " +
                        "For more information about how to use Moderne for automating code refactoring and analysis at scale, " +
                        "[contact us](https://www.moderne.ai/contact-us).\n"
            )

            for (entry in moderneProprietaryRecipesMap) {
                // Artifact ID
                writeln("\n## ${entry.key}\n")

                for (recipe in entry.value.sortedBy { it.name }) {
                    val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe)
                    // Link to Moderne docs since these recipes are exclusive to Moderne
                    writeln("* [${recipe.name}](https://docs.moderne.io/user-documentation/recipes/recipe-catalog/${recipePath})")
                    writeln("  * **${recipe.displayNameEscapedMdx()}**")
                    writeln("  * ${recipe.descriptionEscaped()}")
                }

                writeln("")
            }
        }
    }

    // These are common in every recipe - so let's not use them when generating the list of recipes with data tables.
    private val dataTablesToIgnore = listOf(
        "org.openrewrite.table.SearchResults",
        "org.openrewrite.table.SourcesFileResults",
        "org.openrewrite.table.SourcesFileErrors",
        "org.openrewrite.table.RecipeRunStats"
    )

    fun createRecipesWithDataTables() {
        val recipesWithDataTables = allRecipeDescriptors.filter {
            it.dataTables != null && it.dataTables.any { dataTable -> dataTable.name !in dataTablesToIgnore }
        }

        val recipesWithDataTablesPath = outputPath.resolve("recipes-with-data-tables.md")
        Files.newBufferedWriter(recipesWithDataTablesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
            ---
            description: An autogenerated list of all recipes that contain a unique data table.
            ---
            """.trimIndent()
            )
            writeln("\n# Recipes with Data Tables\n")

            //language=markdown
            writeln(
                "_This doc contains all of the recipes with **unique** data tables that have been explicitly " +
                        "added by the recipe author. If a recipe contains only the default data tables, " +
                        "it won't be included in this list._\n"
            )

            for (recipe in recipesWithDataTables) {
                val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe)
                writeln("### [${recipe.name}](${recipeLinkBasePath}/${recipePath}.md)")
                writeln("  * **${recipe.displayNameEscapedMdx()}**")
                writeln("  * ${recipe.descriptionEscaped()}")

                writeln("\n#### Data tables:\n")

                val filteredDataTables = recipe.dataTables?.filter { dataTable ->
                    dataTable.name !in dataTablesToIgnore
                } ?: emptyList()

                for (dataTable in filteredDataTables) {
                    writeln("  * **${dataTable.name}**: *${escapeMdx(dataTable.description).replace("\n", " ")}*")
                }

                writeln("\n")
            }
        }
    }

    fun createRecipesByTag() {
        val tagToRecipes = TreeMap<String, TreeSet<RecipeDescriptor>>(String.CASE_INSENSITIVE_ORDER)

        // Collect all tags and their associated recipes
        for (recipeDescriptor in allRecipeDescriptors) {
            if (recipeDescriptor.tags != null) {
                for (tag in recipeDescriptor.tags) {
                    tagToRecipes.computeIfAbsent(
                        tag
                            .substringBefore('-')
                            .substringBefore('_')
                    ) { TreeSet(compareBy { it.name }) }
                        .add(recipeDescriptor)
                }
            }
        }

        val markdown = outputPath.resolve("recipes-by-tag.md")
        Files.newBufferedWriter(markdown, StandardOpenOption.CREATE).useAndApply {
            writeln(
                //language=markdown
                """
            ---
            description: An autogenerated list of all recipe tags and the recipes within each tag.
            ---
            
            # Recipes by Tag
            
            _This doc contains all recipe tags and the recipes that are tagged with them._
            
            """.trimIndent()
            )

            if (tagToRecipes.isEmpty()) {
                writeln("No tagged recipes found.")
            } else {
                writeln("Total tags: ${tagToRecipes.size}\n")

                for ((tag, recipes) in tagToRecipes) {
                    writeln("\n## ${tag}")
                    writeln(
                        "\n_${recipes.size} recipe${
                            if (recipes.size != 1) {
                                "s"
                            } else {
                                ""
                            }
                        }_\n"
                    )

                    for (recipe in recipes.sortedBy { it.name }) {
                        val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe)
                        writeln("* [${recipe.name}](${recipeLinkBasePath}/${recipePath}.md)")
                        writeln("  * **${recipe.displayNameEscapedMdx()}**")
                        writeln("  * ${recipe.descriptionEscaped()}")
                    }
                }
            }
        }
    }

    fun createStandaloneRecipes(
        recipeContainedBy: MutableMap<String, MutableSet<RecipeDescriptor>>,
        recipeOrigins: Map<URI, RecipeOrigin>,
        recipeToSource: Map<String, URI>
    ) {
        val standaloneRecipes = allRecipeDescriptors.filterNot { recipe ->
            recipeContainedBy.contains(recipe.name)
        }

        // Skip if there are no recipes to process
        if (standaloneRecipes.isEmpty()) {
            return
        }

        // Write the standalone recipes file
        val standaloneRecipesPath = outputPath.resolve("standalone-recipes.md")
        Files.newBufferedWriter(standaloneRecipesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
            ---
            description: An autogenerated list of recipes that are not included in any composite recipe.
            ---
            """.trimIndent()
            )
            writeln("\n# Standalone Recipes\n")

            writeln(
                "_This doc contains recipes that are not included as part of any larger composite recipe. " +
                        "These recipes can be run independently and are not bundled with other recipes._\n"
            )

            writeln("Total standalone recipes: ${standaloneRecipes.size}\n")

            // Group by package for better organization
            val recipesByArtifact = standaloneRecipes
                .groupBy { recipe ->
                    val source = recipeToSource[recipe.name]
                    val origin = recipeOrigins[source]
                    if (origin != null) {
                        "${origin.groupId}:${origin.artifactId}"
                    } else {
                        "other"
                    }
                }
                .toSortedMap()
            for ((module, recipes) in recipesByArtifact) {
                writeln("\n## ${module}\n")

                for (recipe in recipes.sortedBy { it.name }) {
                    val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe)
                    writeln("* [${recipe.name}](${recipeLinkBasePath}/${recipePath}.md)")
                    writeln("  * **${recipe.displayNameEscapedMdx()}**")
                    writeln("  * ${recipe.descriptionEscaped()}")
                }
            }
        }
    }

    fun createScanningRecipes(
        scanningRecipes: List<Recipe>,
        recipeOrigins: Map<URI, RecipeOrigin>,
        recipeToSource: Map<String, URI>
    ) {
        val markdown = outputPath.resolve("scanning-recipes.md")
        // Use external link for Moderne docs since the concepts page is only on OpenRewrite docs
        val scanningRecipesLink = if (recipeLinkBasePath.contains("user-documentation")) {
            "https://docs.openrewrite.org/concepts-and-explanations/recipes#scanning-recipes"
        } else {
            "/concepts-and-explanations/recipes#scanning-recipes"
        }
        Files.newBufferedWriter(markdown, StandardOpenOption.CREATE).useAndApply {
            writeln(
                //language=markdown
                """
            ---
            description: An autogenerated list of all scanning recipes.
            ---

            # Scanning Recipes

            _This doc contains all [scanning recipes]($scanningRecipesLink)._

            """.trimIndent()
            )


            val recipesByArtifact = scanningRecipes
                .groupBy { recipe ->
                    val source = recipeToSource[recipe.name]
                    val origin = recipeOrigins[source]
                    if (origin != null) {
                        "${origin.groupId}:${origin.artifactId}"
                    } else {
                        "other"
                    }
                }
                .toSortedMap()
            for ((module, recipes) in recipesByArtifact) {
                writeln("\n## ${module}\n")

                for (recipe in recipes.sortedBy { it.name }) {
                    val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe.descriptor)
                    writeln("* [${recipe.descriptor.name}](${recipeLinkBasePath}/${recipePath}.md)")
                    writeln("  * **${recipe.descriptor.displayNameEscapedMdx()}**")
                    writeln("  * ${recipe.descriptor.descriptionEscaped()}")
                }
            }
        }
    }

    fun createAllRecipesByModule(
        recipeOrigins: Map<URI, RecipeOrigin>,
        recipeToSource: Map<String, URI>
    ) {
        // Build a map from module key to its origin for license lookup
        val moduleToOrigin = mutableMapOf<String, RecipeOrigin>()
        for (recipe in allRecipeDescriptors) {
            val source = recipeToSource[recipe.name]
            val origin = recipeOrigins[source]
            if (origin != null) {
                val moduleKey = "${origin.groupId}:${origin.artifactId}"
                moduleToOrigin.putIfAbsent(moduleKey, origin)
            }
        }

        val markdown = outputPath.resolve("all-recipes.md")
        Files.newBufferedWriter(markdown, StandardOpenOption.CREATE).useAndApply {
            writeln(
                //language=markdown
                """
            ---
            description: A comprehensive list of all recipes organized by module.
            ---

            # All Recipes by Module

            _This doc contains all recipes grouped by their module._

            """.trimIndent()
            )

            writeln("Total recipes: ${allRecipeDescriptors.size}\n")

            // Group recipes by groupId:artifactId
            val recipesByModule = allRecipeDescriptors
                .groupBy { recipe ->
                    val source = recipeToSource[recipe.name]
                    val origin = recipeOrigins[source]
                    if (origin != null) {
                        "${origin.groupId}:${origin.artifactId}"
                    } else {
                        "other"
                    }
                }
                .toSortedMap()

            for ((module, recipes) in recipesByModule) {
                writeln("\n## ${module}\n")
                val origin = moduleToOrigin[module]
                val licenseInfo = origin?.license?.name ?: "Unknown"
                writeln("_License: ${licenseInfo}_\n")
                writeln("_${recipes.size} recipe${if (recipes.size != 1) "s" else ""}_\n")

                for (recipe in recipes.sortedBy { it.name }) {
                    val recipePath = RecipeMarkdownGenerator.getRecipePath(recipe)
                    writeln("* [${recipe.name}](${recipeLinkBasePath}/${recipePath}.md)")
                    writeln("  * **${recipe.displayNameEscapedMdx()}**")
                    writeln("  * ${recipe.descriptionEscaped()}")
                }
            }
        }
    }
}
