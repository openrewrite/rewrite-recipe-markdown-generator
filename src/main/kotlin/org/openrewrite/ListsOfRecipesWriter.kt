package org.openrewrite

import org.openrewrite.RecipeMarkdownGenerator.Companion.useAndApply
import org.openrewrite.RecipeMarkdownGenerator.Companion.writeln
import org.openrewrite.config.RecipeDescriptor
import java.net.URI
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.util.*

class ListsOfRecipesWriter(
    val allRecipeDescriptors: List<RecipeDescriptor>,
    val outputPath: Path
) {
    fun createModerneRecipes(moderneProprietaryRecipesMap: TreeMap<String, MutableList<RecipeDescriptor>>) {
        val moderneRecipesPath = outputPath.resolve("moderne-recipes.md")

        Files.newBufferedWriter(moderneRecipesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
        ---
        description: An autogenerated list of recipes that are exclusive to Moderne.
        ---
        """.trimIndent()
            )
            writeln("\n# Moderne Recipes\n")

            writeln(
                "This doc includes every recipe that is exclusive to users of Moderne. " +
                        "For a full list of all recipes, check out our [recipe catalog](https://docs.openrewrite.org/recipes). " +
                        "For more information about how to use Moderne for automating code refactoring and analysis at scale, " +
                        "[contact us](https://www.moderne.ai/contact-us).\n"
            )

            for (entry in moderneProprietaryRecipesMap) {
                // Artifact ID
                writeln("## ${entry.key}\n")

                for (recipe in entry.value.sortedBy { it.displayName }) {
                    writeln(
                        "* [${recipe.displayNameEscaped()}](/recipes/${
                            RecipeMarkdownGenerator.Companion.getRecipePath(
                                recipe
                            )
                        }.md) - _${
                            recipe.descriptionEscaped()
                        }_"
                    )
                }

                writeln("")
            }
        }
    }

    // These are common in every recipe - so let's not use them when generating the list of recipes with data tables.
    private val dataTablesToIgnore = listOf(
        "org.openrewrite.table.SourcesFileResults",
        "org.openrewrite.table.SourcesFileErrors",
        "org.openrewrite.table.RecipeRunStats"
    )

    fun createRecipesWithDataTables() {
        val recipesWithDataTables = allRecipeDescriptors.filter {
            it.dataTables.any { dataTable -> dataTable.name !in dataTablesToIgnore }
        }

        val recipesWithDataTablesPath = outputPath.resolve("recipes-with-data-tables.md")
        Files.newBufferedWriter(recipesWithDataTablesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
            ---
            description: An autogenerated list of all recipes that contain a unique data table.
            ---
            """.trimIndent()
            )
            writeln("\n# Recipes with Data Tables\n")

            //language=markdown
            writeln(
                "_This doc contains all of the recipes with **unique** data tables that have been explicitly " +
                        "added by the recipe author. If a recipe contains only the default data tables, " +
                        "it won't be included in this list._\n"
            )

            for (recipe in recipesWithDataTables) {
                writeln(
                    "### [${recipe.displayNameEscaped()}](/recipes/${
                        RecipeMarkdownGenerator.Companion.getRecipePath(
                            recipe
                        )
                    }.md)\n "
                )
                writeln("_${recipe.name}_\n")
                writeln("${recipe.descriptionEscaped()}\n")
                writeln("#### Data tables:\n")

                val filteredDataTables = recipe.dataTables.filter { dataTable ->
                    dataTable.name !in dataTablesToIgnore
                }

                for (dataTable in filteredDataTables) {
                    writeln("  * **${dataTable.name}**: *${dataTable.description.replace("\n", " ")}*")
                }

                writeln("\n")
            }
        }
    }

    fun createRecipeAuthors() {
        // Collect contributors
        val allContributors = TreeMap<String, MutableSet<RecipeDescriptor>>()
        for (recipeDescriptor in allRecipeDescriptors) {
            for (contributor in recipeDescriptor.contributors) {
                val recipeSet = allContributors.computeIfAbsent(contributor.name) { mutableSetOf() }
                recipeSet.add(recipeDescriptor)
            }
        }

        val recipeAuthorsPath = outputPath.resolve("recipe-authors.md")
        Files.newBufferedWriter(recipeAuthorsPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
            ---
            description: An autogenerated list of all recipe authors ranked by their contributions.
            ---
            """.trimIndent()
            )
            writeln("\n# Recipe Authors\n")

            writeln(
                "_This table lists all recipe authors ranked by the number of recipes they have contributed, from most to least._\n"
            )

            writeln("**Total authors:** ${allContributors.size}\n")

            // Sort authors by number of recipes (descending), then by name for ties
            val sortedAuthors = allContributors.entries.sortedWith(
                compareByDescending<Map.Entry<String, MutableSet<RecipeDescriptor>>> { it.value.size }
                    .thenBy { it.key }
            )

            // Create table header
            writeln("| Rank | Author | Number of Recipes |")
            writeln("|------|--------|-------------------|")

            // Create table rows
            var rank = 1
            var previousCount = -1
            var actualRank = 1

            for ((author, recipes) in sortedAuthors) {
                val recipeCount = recipes.size

                // Handle ties in ranking
                if (recipeCount != previousCount) {
                    actualRank = rank
                    previousCount = recipeCount
                }

                writeln("| $actualRank | $author | $recipeCount |")
                rank++
            }
        }
    }

    fun createRecipesByTag() {
        val tagToRecipes = TreeMap<String, TreeSet<RecipeDescriptor>>(String.CASE_INSENSITIVE_ORDER)

        // Collect all tags and their associated recipes
        for (recipeDescriptor in allRecipeDescriptors) {
            for (tag in recipeDescriptor.tags) {
                tagToRecipes.computeIfAbsent(tag) { TreeSet(compareBy { it.name }) }
                    .add(recipeDescriptor)
            }
        }

        val markdown = outputPath.resolve("recipes-by-tag.md")
        Files.newBufferedWriter(markdown, StandardOpenOption.CREATE).useAndApply {
            writeln(
                //language=markdown
                """
            ---
            description: An autogenerated list of all recipe tags and the recipes within each tag.
            ---
            
            # Recipes by Tag
            
            _This doc contains all recipe tags and the recipes that are tagged with them._
            
            """.trimIndent()
            )

            if (tagToRecipes.isEmpty()) {
                writeln("No tagged recipes found.")
            } else {
                writeln("Total tags: ${tagToRecipes.size}\n")

                for ((tag, recipes) in tagToRecipes) {
                    writeln("## ${tag}")
                    writeln("\n_${recipes.size} recipe${if (recipes.size != 1) "s" else ""}_\n")

                    for (recipe in recipes.sortedBy { it.displayName }) {
                        writeln(
                            "* [${recipe.displayNameEscaped()}](/recipes/${
                                RecipeMarkdownGenerator.Companion.getRecipePath(
                                    recipe
                                )
                            }.md) - _${
                                recipe.descriptionEscaped()
                            }_"
                        )
                    }
                    writeln("")
                }
            }
        }
    }

    fun createStandaloneRecipes(
        recipeContainedBy: MutableMap<String, MutableSet<RecipeDescriptor>>,
        recipeOrigins: Map<URI, RecipeOrigin>
    ) {
        val standaloneRecipes = allRecipeDescriptors.filterNot { recipe ->
            recipeContainedBy.contains(recipe.name)
        }

        // Skip if there are no recipes to process
        if (standaloneRecipes.isEmpty()) {
            return
        }

        // Write the standalone recipes file
        val standaloneRecipesPath = outputPath.resolve("standalone-recipes.md")
        Files.newBufferedWriter(standaloneRecipesPath, StandardOpenOption.CREATE).useAndApply {
            writeln(
                """
            ---
            description: An autogenerated list of recipes that are not included in any composite recipe.
            ---
            """.trimIndent()
            )
            writeln("\n# Standalone Recipes\n")

            writeln(
                "_This doc contains recipes that are not included as part of any larger composite recipe. " +
                        "These recipes can be run independently and are not bundled with other recipes._\n"
            )

            writeln("Total standalone recipes: ${standaloneRecipes.size}\n")

            // Group by package for better organization
            val recipesByArtifact = standaloneRecipes
                .groupBy { recipe -> recipeOrigins[recipe.source]?.artifactId ?: "other" }
                .toSortedMap()
            for ((artifact, recipes) in recipesByArtifact) {
                writeln("## ${artifact}\n")

                for (recipe in recipes.sortedBy { it.displayName }) {
                    writeln(
                        "* [${recipe.displayNameEscaped()}](/recipes/${
                            RecipeMarkdownGenerator.Companion.getRecipePath(
                                recipe
                            )
                        }.md) - _${
                            recipe.descriptionEscaped()
                        }_"
                    )
                }
            }
        }
    }

    fun createScanningRecipes(
        scanningRecipes: List<Recipe>,
        recipeOrigins: Map<URI, RecipeOrigin>
    ) {
        val markdown = outputPath.resolve("scanning-recipes.md")
        Files.newBufferedWriter(markdown, StandardOpenOption.CREATE).useAndApply {
            writeln(
                //language=markdown
                """
            ---
            description: An autogenerated list of all scanning recipes.
            ---
            
            # Scanning Recipes
            
            _This doc contains all [scanning recipes](/concepts-and-explanations/recipes#scanning-recipes)._
            
            """.trimIndent()
            )


            val recipesByArtifact = scanningRecipes
                .groupBy { recipe -> recipeOrigins[recipe.descriptor.source]?.artifactId ?: "other" }
                .toSortedMap()
            for ((artifact, recipes) in recipesByArtifact) {
                writeln("## ${artifact}\n")

                for (recipe in recipes.sortedBy { it.displayName })
                    writeln(
                        "* [${recipe.descriptor.displayNameEscaped()}](/recipes/${
                            RecipeMarkdownGenerator.Companion.getRecipePath(
                                recipe.descriptor
                            )
                        }.md) - _${
                            recipe.descriptor.descriptionEscaped()
                        }_"
                    )
            }
        }
    }
}